<script type="module">
        import * as THREE from '../static/three/three.module.js';
        import { OrbitControls } from '../static/three/OrbitControls.js';
        import { EffectComposer } from '../static/three/EffectComposer.js';
        import { RenderPass } from '../static/three/RenderPass.js';
        import { OutlinePass } from '../static/three/OutlinePass.js';

        // create scene and camera
        const scene = new THREE.Scene();
        var width = document.getElementById('surface').clientWidth;
        var height = document.getElementById('surface').clientHeight;
        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        camera.position.z = 2;

        // create renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        document.getElementById('surface').appendChild(renderer.domElement);

        // create orbit controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.2;
        controls.enableZoom = true;
        controls.zoomSpeed = 0.4;
        controls.minDistance = 1.7;
        controls.maxDistance = 3.5;
        controls.rotateSpeed = 0.5;
        controls.enablePan = false;

        // create outline pass
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const outline_pass = new OutlinePass(new THREE.Vector2(width, height), scene, camera);
        outline_pass.edgeStrength = 3;
        outline_pass.edgeGlow = 2;
        outline_pass.edgeThickness = 2;
        outline_pass.pulsePeriod = 1.5;
        outline_pass.visibleEdgeColor.set('#ffffff');
        outline_pass.hiddenEdgeColor.set('#190a05');
        composer.addPass(outline_pass);

        // create surface
        var geometry = new THREE.BufferGeometry();
        var material = new THREE.MeshBasicMaterial();
        var surface = new THREE.Mesh(geometry, material, name = "surface");
        scene.add(surface);

        // create part surface
        var part_geometry = new THREE.BufferGeometry();
        var part_material = new THREE.MeshBasicMaterial();
        var part_surface = new THREE.Mesh(part_geometry, part_material, name = "part_surface");
        scene.add(part_surface);
        outline_pass.selectedObjects = [part_surface];

        // vertex colors
        var colors = null;
        // part name lookup table
        var part_names = null;
        // vertex mapping to part
        var vertex_labels = null;
        // color lookup table
        var color_table = null;

        // ray caster for mouse click
        var ray_caster = new THREE.Raycaster();
        var mouse_pos = new THREE.Vector2();
        function intersect_obj(event) {
            mouse_pos.x = (event.clientX - renderer.domElement.offsetLeft) / renderer.domElement.clientWidth * 2 - 1;
            mouse_pos.y = -(event.clientY - renderer.domElement.offsetTop) / renderer.domElement.clientHeight * 2 + 1;
            ray_caster.setFromCamera(mouse_pos, camera);
            var intersects = ray_caster.intersectObjects(scene.children, true);
            return intersects.length > 0 ? intersects[0] : null;
        }
        
        renderer.domElement.addEventListener('contextmenu', function (event) {
            function has_annot() {
                return colors && part_names && vertex_labels;
            }
            event.preventDefault();
            if (!has_annot()) {
                return;
            }
            var intersect = intersect_obj(event);
            if (intersect) {
                var part_id = vertex_labels[intersect.face.a];
                create_part_surface(part_id);
            } else {
                // clear part surface index when click on empty space
                part_geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(), 1));
            }
        });

        // render loop
        function render() {
            requestAnimationFrame(render);
            composer.render();
        }
        render();

        function create_part_surface(part_id) {
            var part_indices = [];
            var indices = geometry.index.array;
            for (var i = 0; i < indices.length; i += 3) {
                if (vertex_labels[indices[i]] == part_id || vertex_labels[indices[i + 1]] == part_id || vertex_labels[indices[i + 2]] == part_id) {
                    part_indices.push(indices[i], indices[i + 1], indices[i + 2]);
                }
            }

            part_geometry.setAttribute('position', geometry.getAttribute('position'));
            part_geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(part_indices), 1));

            var part_color = new THREE.Color();
            part_color.setRGB(color_table[part_id][0][0] / 255, color_table[part_id][0][1] / 255, color_table[part_id][0][2] / 255)
            part_surface.material = new THREE.MeshBasicMaterial({color: part_color});
        }
        window.create_part_surface = create_part_surface;

        function load_mesh(data) {
            data = JSON.parse(data);
            var vertices = new Float32Array(data.vertices);
            var indices = new Uint32Array(data.faces);

            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));

            if (colors) {
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3, true));
                surface.material = new THREE.MeshBasicMaterial({ vertexColors: true, });
            }

            // clear part surface index
            part_geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(), 1));

            render();

            document.getElementById('id_annot_select').disabled = false;
        }

        function show_annot_table(color_table) {
            var table = document.getElementById('id_annot_table');
            table.innerHTML = '';
            for (var i = 0; i < color_table.length; i++) {
                var row = table.insertRow(i);
                var cell1 = row.insertCell(0);
                var cell2 = row.insertCell(1);
                cell1.innerHTML = '<button onclick="create_part_surface(' + i + ')" type="button" class="btn btn-default" style="background-color: rgb(' + color_table[i][0][0] + ',' + color_table[i][0][1] + ',' + color_table[i][0][2] + ');"></button>';
                cell2.innerHTML = color_table[i][1];
            }
        }

        function load_annot(data) {
            data = JSON.parse(data);

            vertex_labels = data.label;
            color_table = data.color_table;

            part_names = [];
            for (var i = 0; i < data.color_table.length; i++) {
                part_names.push(data.color_table[i][1]);
            }

            if (!colors) {
                colors = new Float32Array(data.label.length * 3);
                surface.material = new THREE.MeshBasicMaterial({ vertexColors: true });
            }

            for (var i = 0; i < data.label.length; i++) {
                colors[i * 3] = data.color_table[data.label[i]][0][0] / 255.0;
                colors[i * 3 + 1] = data.color_table[data.label[i]][0][1] / 255.0;
                colors[i * 3 + 2] = data.color_table[data.label[i]][0][2] / 255.0;
            }

            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3, true));

            // clear part surface index
            part_geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(), 1));

            show_annot_table(data.color_table);

            render();
        }

        $("#id_mesh_select").change(function () {
            var mesh_name = $(this).children('option:selected').val();
            $.ajax({
                url: "/get_fsaverage_mesh",
                type: "GET",
                data: {
                    "mesh_name": mesh_name
                },
                success: function (data) {
                    load_mesh(data);
                }
            });
        });

        $("#id_annot_select").change(function () {
            var annot_name = $(this).children('option:selected').val();
            $.ajax({
                url: "/get_fsaverage_annot",
                type: "GET",
                data: {
                    "annot_name": annot_name
                },
                success: function (data) {
                    load_annot(data);
                }
            });
        });

        window.addEventListener('resize', function () {
            width = document.getElementById('surface').clientWidth;
            height = document.getElementById('surface').clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });
    </script>